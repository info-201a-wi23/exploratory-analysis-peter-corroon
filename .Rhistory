in_2020
in_2020 <- dates > "2020-01-01" & dates < "2020-12-31"
in_2020
in_2020 <- dates > "2020-01-01" & dates < "2020-12-31"
in_2020
protests_in_2020 <- dates[in_2020]
length(protests_in_2020)
num_protests_in_2020 <- length(protests_in_2020)
num_protests_in_2019 <- length(protests_in_2019)
in_2020 <- dates >= "2020-01-01" & dates <= "2020-12-31"
protests_in_2020 <- dates[in_2020]
# (4.f) Create a vector of only the dates that are in 2019. (2 points)
# Note: If you want only dates after a certain start date, you can use "2020-01-01" with comparison operators (==, >=, <=)
# Store this value in a variable called `protests_in_2019`
in_2019 <- dates >= "2019-01-01" & dates <= "2019-12-31"
protests_in_2019 <- dates[in_2019]
# (4.f) Create a vector of only the dates that are in 2018. (2 points)
# Note: If you want only dates after a certain start date, you can use "2020-01-01" with comparison operators (==, >=, <=)
# Store this value in a variable called `protests_in_2018`
in_2018 <- dates >= "2018-01-01" & dates <= "2018-12-31"
protests_in_2018 <- dates[in_2018]
length(protests_in_2018)
# Reflection 2 (answer in the README.md file)
# When we're doing data analysis work, we always want to test our assumptions and see whether or not patterns align with our expectations or depart from them.
# Before actually calculating the number of protests that occurred in 2018, 2019, 2020, record your guesses for the following questions.
# Guess: Do you think there were more protests in 2019 than in 2018? Why or why not?
# Guess: Do you think there were more protests in 2020 than in 2019? Why or why not?
# (4.g) Now use the length() function to find out how many protests happened in 2018 vs. 2019 vs. 2020.
# Save them in the varaibles `num_protets_in_2018`, `num_protets_in_2019`, `num_protets_in_20120`(3 points)
num_protests_in_2020 <- length(protests_in_2020)
num_protests_in_2019 <- length(protests_in_2019)
num_protests_in_2018 <- length(protests_in_2018)
rm(list = ls())
install.packages("styler")
install.packages("lintr")
library(lintr)
install.packages("lintr")
library(lintr)
library(styler)
styler:::style_selection()
styler:::style_selection()
library("stringr")
# (1.b) Load the data from CountLove by using the following URL: https://countlove.org/data/data.csv
# Save this dataframe into a variable called `protest_data` (1 point)
protest_data <- read.csv("https://countlove.org/data/data.csv")
num_protests <- nrow(protest_data)
# (1.f) How many features (or columns) are recorded for each protest? It's important to know how to find this number programmatically as well as manually
# Save the number of features for each protest in a variable called `num_features` (1 point)
num_features <- ncol(protest_data)
## Part 2: Attendees ------------------------------------------------------
# In this part, you will explore the number of people who participated in the protests
# (2.a) Extract the `Attendees` column into a variable called `num_attendees`  (1 point)
num_attendees <- protest_data$Attendees
# (2.b) What is the fewest number of attendees at a protest?
# Save the number of protests in a variable called `min_attendees` (2 points)
# Hint: Remember to exclude NA values when using the functions below!
min_attendees <- min(num_attendees, na.rm = TRUE)
# (2.c) What is the greatest number of attendees at a protest?
# Save the number of protests in a variable called `max_attendees` (2 points)
max_attendees <- max(num_attendees, na.rm = TRUE)
# (2.d) What is the average (mean) number of attendees at a protest?
# Save the number of protests in a variable called `mean_attendees` (2 points)
mean_attendees <- mean(num_attendees, na.rm = TRUE)
# (2.e) What is the median number of attendees?
# Save the number of protests in a variable called `median_attendees` (2 points)
median_attendees <- median(num_attendees, na.rm = TRUE)
# (2.f) What is the difference between the mean and median number of attendees? Subtract median_attendees from mean_attendees
# Save the difference in a variable called `difference_attendees` (1 point)
difference_attendees <- mean_attendees - median_attendees
sd(attendees)
sd(num_attendees)
num_attendees <- protest_data$Attendees
# (2.b) What is the fewest number of attendees at a protest?
# Save the number of protests in a variable called `min_attendees` (2 points)
# Hint: Remember to exclude NA values when using the functions below!
min_attendees <- min(num_attendees, na.rm = TRUE)
# (2.c) What is the greatest number of attendees at a protest?
# Save the number of protests in a variable called `max_attendees` (2 points)
max_attendees <- max(num_attendees, na.rm = TRUE)
# (2.d) What is the average (mean) number of attendees at a protest?
# Save the number of protests in a variable called `mean_attendees` (2 points)
mean_attendees <- mean(num_attendees, na.rm = TRUE)
# (2.e) What is the median number of attendees?
# Save the number of protests in a variable called `median_attendees` (2 points)
median_attendees <- median(num_attendees, na.rm = TRUE)
sd(num_attendees, na.rm = TRUE)
IQR(num_attendees, na.rm = TRUE)
sd(num_attendees, na.rm = TRUE)
quantile(num_attendees, na.rm = TRUE)
IQR(num_attendees, na.rm = TRUE)
200 + 1.5 * 173
num_attendees <- protest_data$Attendees
# (2.b) What is the fewest number of attendees at a protest?
# Save the number of protests in a variable called `min_attendees` (2 points)
# Hint: Remember to exclude NA values when using the functions below!
min_attendees <- min(num_attendees, na.rm = TRUE)
# (2.c) What is the greatest number of attendees at a protest?
# Save the number of protests in a variable called `max_attendees` (2 points)
max_attendees <- max(num_attendees, na.rm = TRUE)
# (2.d) What is the average (mean) number of attendees at a protest?
# Save the number of protests in a variable called `mean_attendees` (2 points)
mean_attendees <- mean(num_attendees, na.rm = TRUE)
# (2.e) What is the median number of attendees?
# Save the number of protests in a variable called `median_attendees` (2 points)
median_attendees <- median(num_attendees, na.rm = TRUE)
# (2.f) What is the difference between the mean and median number of attendees? Subtract median_attendees from mean_attendees
# Save the difference in a variable called `difference_attendees` (1 point)
difference_attendees <- mean_attendees - median_attendees
dates <- as.Date(protest_data$Date)
# (4.b) What is the most recent date in the dataset? (2 point)
# Store this value in a variable called `most_recent_protest`
most_recent_protest <- dates[num_protests]
# (4.c) What is the earliest date in the dataset? (2 point)
# Store this value in a variable called `earliest_protest`
earliest_protest <- dates[1]
# (4.d) What is the timespan of the dataset â€” in other words, the distance between the earliest protest and most recent protest? (1 point)
# Hint: R can do math with dates pretty well by default!
# Store this value in a variable called `time_span`
time_span <- most_recent_protest - earliest_protest
# (4.e) Now, create a vector of only the dates that are in 2020.
# Note: If you want only dates after a certain start date, you can use "2020-01-01" with comparison operators (==, >=, <=)
# Store this value in a variable called `protests_in_2020` (2 points)
in_2020 <- dates >= "2020-01-01" & dates <= "2020-12-31"
protests_in_2020 <- dates[in_2020]
# (4.f) Create a vector of only the dates that are in 2019. (2 points)
# Note: If you want only dates after a certain start date, you can use "2020-01-01" with comparison operators (==, >=, <=)
# Store this value in a variable called `protests_in_2019`
in_2019 <- dates >= "2019-01-01" & dates <= "2019-12-31"
protests_in_2019 <- dates[in_2019]
# (4.f) Create a vector of only the dates that are in 2018. (2 points)
# Note: If you want only dates after a certain start date, you can use "2020-01-01" with comparison operators (==, >=, <=)
# Store this value in a variable called `protests_in_2018`
in_2018 <- dates >= "2018-01-01" & dates <= "2018-12-31"
protests_in_2018 <- dates[in_2018]
num_protests_in_2020 <- length(protests_in_2020)
num_protests_in_2019 <- length(protests_in_2019)
num_protests_in_2018 <- length(protests_in_2018)
purposes <- protest_data$Event..legacy..see.tags.
# (5.b) How many different unique purposes are listed in the dataset? (1 point)
# Save this number in a variable called `num_purposes`
num_purposes <- length(unique(purposes))
# That's quite a few! Use View() to examine the `purposes` vector. You will notice a common pattern for each purpose, formatted something like this: Civil Rights (Transgender Rights)
# (5.c) To get a summary of just the higher level categories (e.g., just "Civil Rights" and not "(Transgender Rights)"), we're going to use some R functions to extract only the text before the parenthesis and then save them in a variable `high_level_purposes` (5 points)
high_level_purposes <- gsub("\\(.*", "", purposes)
high_level_purposes <- trimws(high_level_purposes)
high_protest_table <- table(high_level_purposes)
View(high_protest_table)
rainier_visits <- c(1518491, 1501621, 1160754, NA)
cascade_visits <- c(30085, 38208, 30885)
# Calculate the sum total of Rainier visits
sum(rainier_visits, na.rm = TRUE)
# Make the Rainier and the North Cascade's visits into a list of vectors, with a tag for each park name
wa_visits <- list(park = "Rainier", "Cascades", visits = rainier_visits, cascade_visits)
wa_visits
wa_visits <- list(Rainier = rainier_visits, Cascades = cascade_visits)
wa_visits
summed_visits <- lapply(wa_visits, sum)
sum(cascade_visits)
sum(rainier_visits, na.rm = TRUE)
summed_visits
4180866+99178
summed_visits <- lapply(wa_visits, sum)
summed_visits
summed_visits <- sapply(wa_visits, sum)
summed_visits
summed_visits <- sapply(wa_visits, sum, na.rm = TRUE)
summed_visits
rainier_visits <- c(1518491, 1501621, 1160754, NA)
cascade_visits <- c(30085, 38208, 30885, NA)
# Calculate the sum total of Rainier visits
sum(rainier_visits, na.rm = TRUE)
# Make the Rainier and the North Cascade's visits into a list of vectors, with a tag for each park name
wa_visits <- list(Rainier = rainier_visits, Cascades = cascade_visits)
wa_visits
# Vector / List Review
# Number of visits to Rainier from 2018-2020: 1518491, 1501621, 1160754
# Number of visits to Cascades from 2018-2020: 30085, 38208, 30885
# Make Rainier's visits into a vector and add an NA value into the vector, as well
rainier_visits <- c(1518491, 1501621, 1160754, NA)
cascade_visits <- c(30085, 38208, 30885, NA)
# Calculate the sum total of Rainier visits
sum(rainier_visits, na.rm = TRUE)
# Make the Rainier and the North Cascade's visits into a list of vectors, with a tag for each park name
wa_visits <- list(Rainier = rainier_visits, Cascades = cascade_visits)
wa_visits
# Calculate the sum total visits for each National Park,
# then assign to the variable summed visits
summed_visits <- sapply(wa_visits, sum, na.rm = TRUE)
# Now add an NA value into each vector in the list above,
# and see if you can figure out how to calculate the sum total visits for each park
pocket_df <- read.csv("Pudding-pockets-salty.csv", stringsAsFactors = FALSE)
pocket_df <- read.csv("https://github.com/the-pudding/data/blob/master/pockets/measurements.csv", stringsAsFactors = FALSE)
View(pocket_df)
pocket_df <- read.csv("https://raw.githubusercontent.com/info-201a-sp22/Week4-Exercises/main/Pudding-pockets-salty.csv", stringsAsFactors = FALSE)
View(pocket_df)
gender_women <- str_detect(gender, "wo")
pocket_df <- read.csv("https://raw.githubusercontent.com/info-201a-sp22/Week4-Exercises/main/Pudding-pockets-salty.csv", stringsAsFactors = FALSE)
# Extract the column "menWomen" from the dataframe and save as the variable `gender`
gender <- pocket_df$menWomen
# How many men's pockets vs women's pockets are in this data?
# First, try to filter the gender vector for only "men." (Hint: your first approach might not work, and you might have to use a built-in function to clean the data!) Then find out how many values correspond to "men"
gender_women <- str_detect(gender, "wo")
gender_women <- str_detect(gender, "wo")
sum(gender_women)
gender(length(gender) > 3)
gender[length(gender) > 3]
gender[length(gender) == 3]
gender[length(gender) = 3]
gender <- pocket_df$menWomen
# How many men's pockets vs women's pockets are in this data?
# First, try to filter the gender vector for only "men." (Hint: your first approach might not work, and you might have to use a built-in function to clean the data!) Then find out how many values correspond to "men"
gender <- trimws(gender)
gender_men <- str_detect(gender, "men")
sum(gender_men)
# Try to filter the gender vector for only "women." (Hint: your first approach might not work, and you might have to use a built-in function to clean the data!) Then find out how many values correspond to "women"
gender_women <- str_detect(gender, "women")
sum(gender_women)
gender_men <- str_detect(gender, "\\w+men")
sum(gender_men)
gender_men
gender_men <- gender[gender == "men"]
gender_men
gender_men <- gender[gender == "men"]
sum(gender_men)
length(gender_men)
?gsub
material <- pocket_df$fabric
first_percent <- gsub("\\%.*", "", material)
report_brand <- function(brand_name) {
spec_brand <- all_brands[str_detect(all_brands, brand_name)]
num_spec_brand <- length(spec_brand)
paste("There are", num_spec_brand, "brands that match", brand_name, "in the dataset.")
}
report_brand("Guess")
all_brands <- pocket_df$brand
report_brand <- function(brand_name) {
spec_brand <- all_brands[str_detect(all_brands, brand_name)]
num_spec_brand <- length(spec_brand)
paste("There are", num_spec_brand, "brands that match", brand_name, "in the dataset.")
}
# Call your function and test it on the brand "Guess"
report_brand("Guess")
report_brand <- function(brand_name) {
num_spec_brand<- sum[str_detect(all_brands, brand_name)]
paste("There are", num_spec_brand, "brands that match", brand_name, "in the dataset.")
}
# Call your function and test it on the brand "Guess"
report_brand("Guess")
# The function should return a message that reads "There are [X] brands that match [Name of Brand] in the dataset."
report_brand <- function(brand_name) {
num_spec_brand<- sum(str_detect(all_brands, brand_name))
paste("There are", num_spec_brand, "brands that match", brand_name, "in the dataset.")
}
# Call your function and test it on the brand "Guess"
report_brand("Guess")
report_brand("Abercrombie")
sapply(all_brands, report_brand)
# Load the pocket size data from the Pudding
# Read more about the data here: https://github.com/the-pudding/data/blob/master/pockets/measurements.csv
pocket_df <- read.csv("Pudding-pockets-salty.csv", stringsAsFactors = FALSE)
pocket_df <- read.csv("https://raw.githubusercontent.com/info-201a-sp22/Week4-Exercises/main/Pudding-pockets-salty.csv", stringsAsFactors = FALSE)
# Extract the column "menWomen" from the dataframe and save as the variable `gender`
gender <- pocket_df$menWomen
# How many men's pockets vs women's pockets are in this data?
# First, try to filter the gender vector for only "men." (Hint: your first approach might not work, and you might have to use a built-in function to clean the data!) Then find out how many values correspond to "men"
gender <- trimws(gender)
gender_men <- gender[gender == "men"]
length(gender_men)
gender_men
# Try to filter the gender vector for only "women." (Hint: your first approach might not work, and you might have to use a built-in function to clean the data!) Then find out how many values correspond to "women"
gender_women <- str_detect(gender, "women")
sum(gender_women)
# Extract the column "maxHeightFront" from the dataframe and save as the variable `front_pockets`
front_pockets <- pocket_df$maxHeightFront
# What is the average height of front pockets in the dataset?
mean(front_pockets, na.rm = TRUE)
# What is the maximum height of front pockets in the dataset "maxHeightFront"?
max(front_pockets, na.rm = TRUE)
# What is the minimum height of front pockets in the dataset "maxHeightFront"?
min(front_pockets, na.rm = TRUE)
# Now we want to analyze the material in the pants fabric, and figure out whether the pants are mostly
# dominated by a single material or more distribuetd between materials
# So we need to extract just the first numbers from the column "fabric"
# Complete this extraction by using gsub()
# Hint: Removing text after a certain string might be the same thing as extracting the string!
material <- pocket_df$fabric
first_percent <- gsub("\\%.*", "", material)
# Extract the column brand into the variable all_brands
all_brands <- pocket_df$brand
# Write a function report_brand() that reports how many pockets from each brand are included in the data
# The function should return a message that reads "There are [X] brands that match [Name of Brand] in the dataset."
report_brand <- function(brand_name) {
num_spec_brand<- sum(str_detect(all_brands, brand_name))
paste("There are", num_spec_brand, "brands that match", brand_name, "in the dataset.")
}
# Call your function and test it on the brand "Guess"
report_brand("Guess")
# Call your function and test it on the brand "Abercrombie"
report_brand("Abercrombie")
# Call your function on the entire column brand with sapply()
sapply(all_brands, report_brand)
pocket_df <- read.csv("https://github.com/the-pudding/data/raw/master/pockets/measurements.csv")
# Install tidyverse
# install.packages("tidyverse")
# Load dplyr
install.packages("tidyverse")
library(dplyr)
# Make a new dataframe with only the columns "brand" and "price" and save as new_df
new_df <- data.frame(brand, price)
new_df <- data.frame(pocket_df$brand, pocket_df$price)
View(new_df)
pocket_df <- read.csv("https://github.com/the-pudding/data/raw/master/pockets/measurements.csv")
# Install tidyverse
# install.packages("tidyverse")
# Load dplyr
install.packages("tidyverse")
library(dplyr)
# Make a new dataframe with only the columns "brand" and "price" and save as new_df
new_df <- select(brand, price)
new_df <- select(pocket_df, brand, price)
women_pockets <- pocket_df %>%
filter(gender == "women")
# Filter the dataframe for only men and save as the variable men_pockets
women_pockets <- pocket_df %>%
filter(gender == "men")
# Calculate the average front pocket size for women and save as w_avg_front
w_avg_front <- women_pockets %>%
summarize(mean(maxHeightFront))
# Calculate the average front pocket size for men and save as m_avg_front
m_avg_front <- men_pockets %>%
summarize(mean(maxHeightFront))
men_pockets <- pocket_df %>%
filter(gender == "men")
# Calculate the average front pocket size for women and save as w_avg_front
w_avg_front <- women_pockets %>%
summarize(mean(maxHeightFront))
# Calculate the average front pocket size for men and save as m_avg_front
m_avg_front <- men_pockets %>%
summarize(mean(maxHeightFront))
# Find the proportion between women's and men's front pocket sizes
# Divide w_avg_front / m_avg_front
w_avg_front / m_avg_front
w_avg_front <- women_pockets %>%
summarize(mean(maxHeightFront))
w_avg_front <- women_pockets %>%
summarize(mean(maxHeightFront))
w_avg_front
# Calculate the average front pocket size for men and save as m_avg_front
m_avg_front <- men_pockets %>%
summarize(mean(maxHeightFront))
m_avg_front
new_df <- pocket_df %>% select(brand, price)
new_df <- pocket_df %>% select(brand, price)
# Filter the dataframe for only women and save as the variable women_pockets
women_pockets <- pocket_df %>%
filter(gender == "women")
# Filter the dataframe for only men and save as the variable men_pockets
men_pockets <- pocket_df %>%
filter(gender == "men")
# Calculate the average front pocket size for women and save as w_avg_front
w_avg_front <- women_pockets %>%
summarize(mean(maxHeightFront))
w_avg_front
# Calculate the average front pocket size for men and save as m_avg_front
m_avg_front <- men_pockets %>%
summarize(mean(maxHeightFront))
m_avg_front
# Find the proportion between women's and men's front pocket sizes
# Divide w_avg_front / m_avg_front
w_avg_front / m_avg_front
w_avg_back <- women_pockets %>%
summarize(mean(maxHeightBack))
# Calculate the average back pocket size for men
m_avg_back <- men_pockets %>%
summarize(mean(maxHeightBack))
# Find the the proportion between women's and men's back pocket sizes
# Divide w_avg_back / m_avg_back
w_avg_back / m_avg_back
shootings_data <- read.csv("Mother Jones - Mass Shootings Database, 1982 - 2023 - Sheet1 (2).csv")
shootings_data <- read.csv("Mother Jones - Mass Shootings Database, 1982 - 2023 - Sheet1 (2).csv")
shootings_data <- read.csv("Mother Jones - Mass Shootings Database, 1982 - 2023.csv")
setwd("~/Desktop/info201code/exploratory-analysis-peter-corroon")
#load libraries
library(tidyverse)
library(dplyr)
library(ggplot2)
library(reshape2)
#read in data
shootings_df <- read.csv("~/Desktop/Mass-Shootings-Database.csv", stringsAsFactors = FALSE)
#AGGREGATE TABLE
#Use dplyr to produce a table of aggregate information from the data set
# ------------------------------------------------------------------------------
#Load in necessary libraries
library("dplyr")
library("tidyverse")
library("ggplot2")
#Load in the data set
ms_df <- read.csv("~/Desktop/mass-shootings.csv", stringsAsFactors = FALSE) %>%
filter(year != "2023")
rm(list = ls())
spl_data <- read.csv("2022-2023-All-Checkouts-SPL-Data.csv", stringsAsFactors = FALSE)
setwd("~/Desktop/info201code/a3-spl-checkouts-clairelongcore")
rm(list = ls())
spl_data <- read.csv("2022-2023-All-Checkouts-SPL-Data.csv", stringsAsFactors = FALSE)
summary_info <- list()
summary_info$num_obs <- nrow(spl_data)
summary_info$max_checkouts <- spl_data %>%
filter(Checkouts == max(Checkouts, na.rm = T)) %>%
select(Title)
summary_info$max_checkout_month <- spl_data %>%
group_by(CheckoutMonth) %>%
summarize(checkout_by_month = sum(Checkouts)) %>%
filter(checkout_by_month == max(checkout_by_month, na.rm = T)) %>%
select(CheckoutMonth)
summary_info$average_audiobook <- spl_data %>%
group_by(MaterialType) %>%
summarize(avg_checkouts = mean(Checkouts, na.rm = T)) %>%
filter(MaterialType == "AUDIOBOOK") %>%
select(avg_checkouts)
summary_info$average_physical_book <- spl_data %>%
group_by(MaterialType) %>%
summarize(avg_checkouts = mean(Checkouts, na.rm = T)) %>%
filter(MaterialType == "BOOK") %>%
select(avg_checkouts)
View(summary_info)
There were a total of `summary_info$num_obs` checkouts from SPL libraries in 2022 and 2023, with the most popular title being checked out `summary_info$max_checkouts`.
rm(list = ls())
spl_data <- read.csv("2022-2023-All-Checkouts-SPL-Data.csv", stringsAsFactors = FALSE)
library(dplyr)
library(tidyverse)
library(ggplot2)
summary_info <- list()
summary_info$num_obs <- nrow(spl_data)
summary_info$max_checkouts <- spl_data %>%
filter(Checkouts == max(Checkouts, na.rm = T)) %>%
select(Title)
summary_info$max_checkout_month <- spl_data %>%
group_by(CheckoutMonth) %>%
summarize(checkout_by_month = sum(Checkouts)) %>%
filter(checkout_by_month == max(checkout_by_month, na.rm = T)) %>%
select(CheckoutMonth)
summary_info$average_audiobook <- spl_data %>%
group_by(MaterialType) %>%
summarize(avg_checkouts = mean(Checkouts, na.rm = T)) %>%
filter(MaterialType == "AUDIOBOOK") %>%
select(avg_checkouts)
summary_info$average_physical_book <- spl_data %>%
group_by(MaterialType) %>%
summarize(avg_checkouts = mean(Checkouts, na.rm = T)) %>%
filter(MaterialType == "BOOK") %>%
select(avg_checkouts)
library("tidyverse")
library(dplyr)
library(tidyverse)
library(ggplot2)
spl_data <- spl_data %>%
mutate(total_date = paste0(CheckoutYear, "-", CheckoutMonth, "-01"))
spl_data$total_date <- as.Date(spl_data$total_date, format = "%Y-%m-%d")
ggplot(spl_data) +
geom_point(aes(x = total_date, y = Checkouts, color = UsageClass)) +
jitter(x = total_date, factor = 1, amount = .1)
View(summary_info)
library("dplyr")
library("tidyverse")
library("ggplot2")
types_included <- c("BOOK", "AUDIOBOOK", "VIDEODISC", "EBOOK", "VISUAL", "ER, SOUNDREC", "ATLAS", "SOUNDDISC", "MAP", "NOTATEDMUSIC")
avg_checkout_by_type <- spl_data %>%
group_by(MaterialType) %>%
summarize(by_type = mean(Checkouts, na.rm = T))
ggplot(data = avg_checkout_by_type) +
geom_bar(mapping = aes(x = MaterialType, y = by_type))
View(avg_checkout_by_type)
View(avg_checkout_by_type)
setwd("~/Desktop/info201code/exploratory-analysis-peter-corroon")
#Chart 1
rm(list = ls())
shootings_data <- read.csv("Mass-Shootings-Database-copy.csv", stringsAsFactors = FALSE)
library("dplyr")
library("tidyverse")
shootings_data[shootings_data == "-"] <- NA
shootings_data[shootings_data == "Unknown"] <- NA
shootings_data[shootings_data == "TBD"] <- NA
shootings_data
install.packages("maps")
# Load libraries
library("ggplot2")
#  library("plotly")
library("dplyr")
state_shape <- map_data("state")
no_na_lat_long <- shootings_data %>%
drop_na(latitude) %>%
drop_na(longitude)
num_lat_long <- transform(no_na_lat_long,
latitude = as.numeric(latitude))
num_lat_long <- transform(num_lat_long, longitude = as.numeric(longitude))
str(num_lat_long)
ggplot(data = state_shape) +
geom_polygon(aes(x = long,
y = lat,
group = group)) +
geom_point(data = num_lat_long, aes(x = longitude,
y = latitude, color = "red")) +
coord_map(xlim = c(-125, -65), ylim = c(50, 25)) +
labs(
title = "Locations of US Mass Shootings",
x = "Longitude",
y = "Latitude",
color = "Location") +
theme(
plot.background = element_blank(),
legend.position = "none")
blank_theme
